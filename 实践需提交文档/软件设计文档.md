{:toc}





# 一、开发

## 开发人员

|   学号   |  昵称   |                    Github                     |             岗位角色             |
| :------: | :-----: | :-------------------------------------------: | :------------------------------: |
| 16340213 | 阿里武* |    [wangjiwu](https://github.com/wangjiwu)    |    项目经理、产品经理，架构师    |
| 16340204 | 汤小纪* | [13326651141](https://github.com/13326651141) | 客户经理、UI/UX设计师，QA 工程师 |
| 16340205 |  小鹏*  |  [Walikrence](https://github.com/Walikrence)  |     Python工程师， 数据库DBA     |
| 16340111 |  李冰   |     [Lyrix28](https://github.com/Lyrix28)     |     Python工程师，数据库DBA      |
| 15353005 | 范瑞潮* |     [Sefaice](https://github.com/Sefaice)     |     Js工程师， DevOps 工程师     |

## 开发计划

项目共分为4个迭代，分别是 **项目启动、问卷系统迭代、 小任务系统迭代、测试和文档完善**， 以下是每个迭代的具体计划。

- **inceptions 1 项目启动（ 2019-03-27 ~ 2019-04-19）**

  - 目标:

    - 开会讨论项目课题， 架构， 分工
  - 完成市场调研， 项目愿景， 项目规格说明书
    - 注册登录实现

  - 工作：

    - 产品调查/市场调研：汤浩林
  - 前端登陆/注册：范瑞潮
    - 后端登陆/注册API： 汤万鹏 & 李冰
    - 项目规格说明书： 王继武
    - 项目愿景等文档：汤浩林
  - 业务故事板设计：王继武
  
- 项目会议：
  
    - 3.27 meeting1 所有人
    - 4.13 meeting2 所有人
  
  - 完成情况
  
  基本完成， 还有几个图不会， 后期将会补上
  
- **Iteration 2 问卷系统迭代 ( 2019-04-20 ~ 2019-05-10 )**

  - 目标:

    - 完成API文档设计
  - 完成数据库设计
    - 完成问卷系统前端逻辑
  - 完成问卷系统后端逻辑
  
- 会议：
  
  - 4.20 meeting3 所有人
  
  - 工作
  
    - API设计 李冰
  - 后端问卷系统：汤万鹏
    - 前端UI设计：汤浩林
  - 前端逻辑实现：范瑞潮
    - 需求说明书：王继武

  - 完成情况

    完成
  
- **Iteration 3 小任务系统迭代 (4 周 2019-05-10 ~ 2019-06-10)**

  - 目标:

    - 完成个人博客
  - 项目文档整理
    - 小任务系统实现
  - 完成问卷系统后端逻辑
  
- 会议：
  
  - 5.10 meeting4 所有人
  
  - 工作
  
    - 小任务API设计 李冰
  - 后端小任务系统：汤万鹏
    - 小任务UI设计：汤浩林
  - 小任务前端逻辑实现：范瑞潮
    - 项目文档整理：王继武

  - 完成情况

    UI需要再补充一下

- **Iteration 4 测试和文档完善 (2周 2019-06-15 ~ 2019-06-25)**

  - 目标:

    - 完成技术报告
    - 文档完善
    - 系统测试

  - 会议：

    - 6.10 meeting5 所有人

  - 工作

    - 后端测试： 李冰 & 汤万鹏
    - 项目测试：汤浩林
    - 前端测试：范瑞潮
    - 项目文档完善：王继武

  - 完成情况

    完成



## 开发环境和工具

### 前端环境和框架

技术栈

vue 2.9.6 + vuex 2.0.0 + axios

开发环境

windows 10  +  sublime

nodejs 8.12.0 + vue-cli 2.9.6



### 后端环境和框架

开发环境
mac os + sublime

技术栈
django 2.1.7 + SQLite + apache

部署环境
Ubuntu 18.04.2 LTS 



### UI 设计环境和工具

Windows10   + AXURE RP



## 生产规范

#### 1. 前端规范

前端采用Vue.js开发， 采用的规范如下

##### 基于组件化开发理解

- 什么是组件？

  ```
       组件其实就是页面组成的一部分，好比是电脑中的每一个元件（如硬盘、键盘、鼠标），它是一个具有独立的逻辑和功能或界面，同时又能根据规定的接口规则进行相互融化，变成一个完整的应用。
       页面只不过是这样组件的容器，组件自由组合形成功能完整的界面，当不需要某个组件，或者想要替换某个组件时，可以随时进行替换和删除，而不影响整个应用的运行。前端组件化的核心思想就是将一个巨大复杂的东西拆分成粒度合理的小东西。
  ```

- 组件化开发的好处

  ```
     提高开发效率
     方便重复使用
     简化调试步骤
     提升整个项目的可维护性
     便于协同开发
     使其高内聚，低耦合，达到分治与复用的目的。
  ```

- 组件化和模块化的区别

  ```
  组件化是从产品功能角度进行分割，模块化是从代码实现角度进行分割，模块化是组件化的前提和基础。
  ```

- Vue组件化开发

  

  ```
     单文件系统，样式局部作用域
     基本组成结构：<template/> <script/> <style scoped/>
     组件注册方式：1）公共组件全局注册 2）其余组件局部注册
  ```

##### 组件命名规范

Vue官方文档给予以下说明：

```
当注册组件 (或者 prop) 时，可以使用 kebab-case (短横线分隔命名)、camelCase (驼峰式命名) 或 PascalCase (单词首字母大写命名)。
PascalCase 是最通用的声明约定而 kebab-case 是最通用的使用约定。
```

命名可遵循以下规则：

```
 1、有意义的名词、简短、具有可读性
 2、以小写开头，采用短横线分割命名
 3、公共组件命名以公司名称简拼为命名空间(app-xx.vue)
 4、文件夹命名主要以功能模块代表命名
 同时还需要注意：必须符合自定义元素规范: 使用连字符分隔单词，切勿使用保留字。app- 前缀作为命名空间: 如果非常通
```

##### 结构化规范

- 基于Vue-cli脚手架的结构基础划分

  ```
     ├── index.html                      入口页面
     ├── build                           构建脚本目录
     │   ├── build-server.js                 运行本地构建服务器，可以访问构后的页面
     │   ├── build.js                        生产环境构建脚本
     │   ├── dev-client.js                   开发服务器热重载脚本，主要用来实现开发阶段的页面自动刷新
     │   ├── dev-server.js                   运行本地开发服务器
     │   ├── utils.js                        构建相关工具方法
     │   ├── webpack.base.conf.js            wabpack基础配置
     │   ├── webpack.dev.conf.js             wabpack开发环境配置
     │   └── webpack.prod.conf.js            wabpack生产环境配置
     ├── config                          项目配置
     │   ├── dev.env.js                      开发环境变量
     │   ├── index.js                        项目配置文件
     │   ├── prod.env.js                     生产环境变量
     │   └── test.env.js                     测试环境变量
     ├── mock                            mock数据目录
     │   └── hello.js
     ├── package.json                    npm包配置文件，里面定义了项目的npm脚本，依赖包等信息
     ├── src                             项目源码目录    
     │   ├── main.js                         入口js文件
     │   ├── App.vue                         根组件
     │   ├── components                      公共组件目录
     │   │   └── title.vue
     │   ├── assets                          资源目录，这里的资源会被wabpack构建
     │   │   ├── css                         公共样式文件目录
     │   │   ├── js                          公共js文件目录
     │   │   └── img                      图片存放目录
     │   ├── routes                          前端路由
     │   │   └── index.js
     │   ├── store                           应用级数据（state）
     │   │   └── index.js
     │   └── views                           页面目录
     │       ├── hello.vue
     │       └── notfound.vue
     ├── static                          纯静态资源，不会被wabpack构建。
     └── test                            测试文件目录（unit&e2e）
         └── unit                            单元测试
             ├── index.js                        入口脚本
             ├── karma.conf.js                   karma配置文件
             └── specs                           单测case目录
                 └── Hello.spec.js
  ```

- vue文件基本结构

  

```
        <template>
          <div>
            <!--必须在div中编写页面-->
          </div>
        </template>
        <script>
          export default {
            components : {
            },
            data () {
              return {
              }
            },
            methods: {
            },
            mounted() {
        
            }
         }
        </script>
        <!--声明语言，并且添加scoped-->
        <style lang="less" scoped>
        </style>
```

- vue文件方法声明顺序

  ```
      - components   
      - props    
      - data     
      - created
      - mounted
      - activited
      - update
      - beforeRouteUpdate
      - metods   
      - filter
      - computed
      - watch
  ```



##### 注释规范

代码注释在一个项目的后期维护中显的尤为重要，所以我们要为每一个被复用的组件编写组件使用说明，为组件中每一个方法编写方法说明。
以下情况，务必添加注释

```
1.公共组件使用说明
2.各组件中重要函数或者类说明
3.复杂的业务逻辑处理说明
4.特殊情况的代码处理说明,对于代码中特殊用途的变量、存在临界值、函数中使用的hack、使用了某种算法或思路等需要进行注释描述
5.注释块必须以/**（至少两个星号）开头**/；
6.单行注释使用//；
```

##### 编码规范

优秀的项目源码，即使是多人开发，看代码也如出一人之手。统一的编码规范，可使代码更易于阅读，易于理解，易于维护。**尽量按照ESLint格式要求编写代码**



```
    1.使用ES6风格编码源码
        定义变量使用let ,定义常量使用const
        使用export ，import 模块化
    2.组件 props 原子化
        提供默认值
        使用 type 属性校验类型
        使用 props 之前先检查该 prop 是否存在
    3.避免 this.$parent
    4.谨慎使用 this.$refs
    5.无需将 this 赋值给 component 变量
    6.调试信息console.log() debugger 使用完及时删除
    
```



#### 2 . 后端规范   

后端采用Python+Django ，规范如下：

##### 缩进

- 统一使用4个空格进行缩进

##### 行宽

每行代码尽量不超过80个字符(在特殊情况下可以略微超过80，但最长不得超过120)

理由：

- 这在查看side-by-side的diff时很有帮助
- 方便在控制台下查看代码
- 太长可能是设计有缺陷

##### 引号

简单说，自然语言使用双引号，机器标示使用单引号，因此代码里多数应该使用单引号

##### 空行

- 模块级函数和类定义之间空两行；
- 类成员函数之间空一行；

空格

- 在二元运算符两边各空一格 `[=,-,+=,==,>,in,is not, and]`:
- 函数的参数列表中，`,`之后要有空格
- 函数的参数列表中，默认值等号两边不要添加空格
- 字典对象的左括号之前不要多余的空格

##### 换行

Python支持括号内的换行。这时有两种情况。

- 第二行缩进到括号的起始处
- 第二行缩进4个空格，适用于起始括号就换行的情形
- 禁止复合语句，即一行中包含多个语句：
- `if/for/while`一定要换行：

##### 注释

块注释

- `“#”`号后空一格，段落件用空行分开（同样需要“#”号）

行注释

- 至少使用两个空格和语句分开，注意不要使用无意义的注释



##### 命名规范

- 应避免使用小写字母`l(L)`，大写字母`O(o)`或`I(i)`单独作为一个变量的名称，以区分数字1和0;
- 包和模块使用全小写命名，尽量不要使用下划线
- 类名使用`CamelCase`命名风格，内部类可用一个下划线开头
- 函数使用下划线分隔的小写命名
- 当参数名称和Python保留字冲突，可在最后添加一个下划线，而不是使用缩写或自造的词
- 常量使用以下划线分隔的大写命名



# 二、软件总体设计

## 产品设计







## 界面设计





## 交互设计





## 前端设计

### 软件设计技术



###  技术选型及理由



###  模块划分



## 后端设计

### 软件架构设计





### 技术选型及理由

#### django

Django 是以 Python 编写的高级，MVC 风格的开源库。 Django 也被称为“完美主义者的最后框架”，它最初是为新闻网站设计的，并且允许开发人员编写数据库驱动Web应用程序，因此无需从头开始编码。

除了更快完成常见的 Web 开发任务，Django 还能使设计过程干净务实。 Django 是新的 Python Web 开发人员的最佳选择，其官方文档和教程是软件开发中最好的。

在技术市场充斥着一系列网络框架，但 Django 一直是最受欢迎的服务器端 Web 框架。设计 Django 最初的原因是：不要重复造轮子。 Django 是用 Python 编写的，通过最小化编写代码来提高效率，再加上云平台的支持，使Django 成为 Web 开发者最受欢迎的选择。

#### Django的主要特点

1. Django配有“Batteries-Included"
   Django 基于 “Batteries-Included” 的理念，可不必使用单独的库来实现常见功能，例如身份验证，URL 路由，模板系统，对象关系映射器（ORM）和数据库模式迁移。如果您正在使用或使用 Flask，您必须注意到它要求一个单独的库，如用 Flask-Login 来执行用户身份验证，而 Django 不必这样做。
2. 免费 API
   使用 Django，可以根据您的模型生成 Python API，不需要额外的编码就能够生成 API 了。
3. 独特的管理界面
   即使在网站完全构建之前，您也可以从外部贡献者的网站上获取有关信息，这就是 Django 的优点。该框架使您能够快速轻松地从应用程序的模型中创建一个管理站点。
4. 代码布局
   与大多数 Web 框架相反，Django 通过使用称为 application 的东西，更容易地将新功能插入到产品中。因此，开发人员一直被鼓励编写自包含的代码。
5. Django 的 ORM 专注于数据库
   Django 的对象关系映射器（ORM）负责处理数据库,所以没有处理结构化查询语言（SQL）那样的麻烦，它主要用于查询数据库所需的数据。与许多通过SQL 直接在数据库上工作的 Python 框架不同，Django 开发人员有一个独特的工具来操纵相应的 Python 模型对象。 Django 通过使用 PostgreSQL，MySQL，SQLite 和 Oracle 等关系数据库管理系统来实现开箱即用的功能。
6. 强大的内置模板系统
   基于继承系统，Django 的模板允许开发人员从非常少量的前端代码构建整个动态网站，通过使用上下文特定元素来替换模板的某些元素选项。想象一下，你知道你网站的每个页面都会有一个页眉和一个页脚。现在，您首先需要在网站的基本模板中编写代码。然后，您可以从应用程序的其他部分动态地更改这两个内容之间的组件。
7. 简单可读的 URL
   一般来说，很难正确阅读在 PHP os ASP 中开发的 URL。使用 Django，您可以创建简单易读的 URL，这对人和搜索引擎都有好处。您也可以使用其他框架创建可读 URL，但没有一个与 Django 一样容易进行 URL 构造。
8. 快速启动，轻松创建 RSS 和 Atom 订阅源
   使用 Django，您可以通过创建一个简单的 Python 类来快速，轻松地创建 RSS和 Atom 订阅源
9. 自动创建数据库中的表
   如果数据库中缺少表，可以通过在 Django 中执行 migrate 命令来自动创建表
10. 轻松的数据库迁移
    Django 最有用的功能之一就是数据库迁移。使用 Django 的迁移，您可以快速更改数据库模式，跟踪您的数据库模式以及进行相关更改。迁移名称有助于管理版本控制，并且可以使用多种选项来合并版本并进行修改。
11. 安全
    Django 是高度安全的。该框架具有针对 XSS 攻击，CSRF 攻击，SQL 注入，点击劫持，用户管理，Cookie，电子邮件标题注入，加密，目录遍历等的默认保护。

Django 有一个非常活跃的社区，有 80,000 个 StackOverflow 问题和来自开发人员和高级用户的许多博客。一些流行的使用 Django 的网站是 Bitbucket，Pinterest，Instagram 和 Theionion。 Django 将会成为 Python 开发人员最受欢迎的选择



### 模块划分

```sh
├── api.md
├── db.sqlite3
├── dist
│   ├── index.html
│   └── static
│       ├── css
│       │   ├── app.88022460.css
│       │   └── chunk-vendors.3b2d6e5b.css
│       ├── favicon.ico
│       ├── img
│       │   ├── avatar.f5009b8c.jpg
│       │   ├── home-carousel-1.70735838.png
│       │   ├── home-carousel-2.8b347fd3.jpg
│       │   ├── home-carousel-3.d201e704.jpg
│       │   ├── home-carousel-4.4d24e122.jpg
│       │   ├── home-detail-1.bbc5b2ce.jpg
│       │   └── home-detail-2.541c6dfc.jpg
│       └── js
│           ├── app.135b342f.js
│           ├── app.135b342f.js.map
│           ├── chunk-vendors.55b965b0.js
│           └── chunk-vendors.55b965b0.js.map
├── makefile
├── manage.py
├── mission
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── mypro
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-37.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── paper
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-37.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── tests.cpython-37.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── views.cpython-37.pyc
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── 0002_delete_user.py
│   │   ├── 0003_auto_20190624_1155.py
│   │   ├── 0004_auto_20190624_1156.py
│   │   ├── 0005_auto_20190624_1928.py
│   │   ├── 0006_paper_creater.py
│   │   ├── 0007_auto_20190625_0359.py
│   │   ├── 0008_auto_20190625_0415.py
│   │   ├── 0009_auto_20190625_0511.py
│   │   ├── 0010_auto_20190625_0525.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       ├── 0001_initial.cpython-37.pyc
│   │       ├── 0002_delete_user.cpython-37.pyc
│   │       ├── 0003_auto_20190624_1155.cpython-37.pyc
│   │       ├── 0004_auto_20190624_1156.cpython-37.pyc
│   │       ├── 0005_auto_20190624_1928.cpython-37.pyc
│   │       ├── 0006_paper_creater.cpython-37.pyc
│   │       ├── 0007_auto_20190625_0359.cpython-37.pyc
│   │       ├── 0008_auto_20190625_0415.cpython-37.pyc
│   │       ├── 0009_auto_20190625_0511.cpython-37.pyc
│   │       ├── 0010_auto_20190625_0525.cpython-37.pyc
│   │       └── __init__.cpython-37.pyc
│   ├── models.py
│   ├── tests.py
│   ├── urls.py
│   └── views.py
└── users
    ├── __init__.py
    ├── __pycache__
    │   ├── __init__.cpython-37.pyc
    │   ├── admin.cpython-37.pyc
    │   ├── models.cpython-37.pyc
    │   ├── test.cpython-37.pyc
    │   ├── tests.cpython-37.pyc
    │   ├── urls.cpython-37.pyc
    │   └── views.cpython-37.pyc
    ├── admin.py
    ├── apps.py
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── 0002_auto_20190623_0502.py
    │   ├── 0003_auto_20190625_0448.py
    │   ├── 0004_auto_20190625_1359.py
    │   ├── __init__.py
    │   └── __pycache__
    │       ├── 0001_initial.cpython-37.pyc
    │       ├── 0002_auto_20190623_0502.cpython-37.pyc
    │       ├── 0003_auto_20190625_0448.cpython-37.pyc
    │       ├── 0004_auto_20190625_1359.cpython-37.pyc
    │       └── __init__.cpython-37.pyc
    ├── models.py
    ├── templates
    │   └── users
    │       └── index.html
    ├── tests.py
    ├── urls.py
    └── views.py
```

### 数据库设计

```py
class User(models.Model):

	gender = (
	    ('male', '男'),
	    ('female', '女')
	)

	name = models.CharField(max_length=128, unique=True)
	password = models.CharField(max_length=256, default='123456')
	email = models.EmailField(default='asd@asd')
	sex = models.CharField(max_length=32, choices=gender, default='男')

	def __str__(self):
		return self.name
class Paper(models.Model):
	title = models.CharField(max_length=128)
	select_question_num = models.IntegerField(default=0)
	fill_question_num = models.IntegerField(default=0)
	creater = models.CharField(max_length=128)

class Question_select(models.Model):
	paper = models.ForeignKey(Paper, on_delete=models.CASCADE)
	title = models.CharField(max_length=128)
	option_num = models.IntegerField(default=0)
	mytype = models.CharField(max_length=128)

class Option(models.Model):
	question = models.ForeignKey(Question_select, on_delete=models.CASCADE)
	text = models.CharField(max_length=128)
	vote_num = models.IntegerField(default=0)

class Question_fill(models.Model):
	paper = models.ForeignKey(Paper, on_delete=models.CASCADE)
	title = models.CharField(max_length=128)

class Question_fill_answer(models.Model):
	question = models.ForeignKey(Question_fill, on_delete=models.CASCADE)
	answer = models.CharField(max_length=128)
	author = models.CharField(max_length=128,default='null')

class Option_vote(models.Model):
	option = models.ForeignKey(Option, on_delete=models.CASCADE)
	voter = models.CharField(max_length=128, default='null')
```





### 接口API设计

##### 1、协议

使用https协议

##### 2.、域名

应该尽量将API部署在专用域名之下。

https://api.bangbangbao.com

##### 3、路径

由于REST API是面向资源的，所以路径中只能出现名词，不能出现动词，所用名词尽量参考数据库表的设计,例如： https://bangbangbao.com/ user /{username}

##### 4、http请求方式

1. GET（SELECT）：从服务器取出资源（一项或多项）。
2. POST（CREATE）：在服务器新建一个资源。
3. PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。

使用例子：

GET /paper：列出所有问卷

POST /paper：创建问卷

GET /user /{username}：获取某个指定电影的信息

##### 5、过滤信息

如果对资源的需求不是全部，那么需要提供过滤的参数，例如：

https://owl.com/v1/movies?name=abc *返回名字为abc的电影*

##### 6、数据

使用json数据格式进行数据传递。

##### 7、状态码

200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。

201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。

202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）

204 NO CONTENT - [DELETE]：用户删除数据成功。

400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。

401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。

403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。

404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。

406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。

410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。

422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。

500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。

##### 8、错误处理

如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 使用详细的错误包装错误：

```
{
  "errors": [
   {
    "userMessage": "Sorry, the requested resource does not exist",
    "internalMessage": "No car found in the database",
    "code": 34,
    "more info": "http://dev.mwaysolutions.com/blog/api/v1/errors/12345"
   }
  ]
}
```



## 架构设计



### 1 .架构问题

#### 可靠性和可恢复性

- 因素：web应用使用过程中出现访问服务端中断问题并进行恢复
- 度量和质量场景：当web应用访问服务端中断时，在正常的工作环境下，如果在5s内检测到其恢复，则重新建立连接， 否则提示用户无法连接
- 可变性：在能够重新建立连接之前，可以在客户端进行一些操作， 存在在web缓存中
- 该因素对涉众、架构以及其他因素的影响 ：web用户提交的数据可能会发生丢失，无法传递给服务端
- 对于成功的优先级 ：高
- 困难或风险：中等

### 2. 解决方案说明

#### 可靠性和可恢复性解决方案

当出现访问服务端中断问题时，

- 首先进行重新连接，
- 如果失败则进入离线模式， 其中和服务器的发送接收操作不可用，
- 但是可以进行问卷创建等操作， 这些离线模式下的数据将存储在浏览器缓存中，不会

### 3 .物理视图

![img](https://walikrence.github.io/swsad-project/images/%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E/%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84.png)

### 4. 逻辑视图

![img](https://walikrence.github.io/swsad-project/images/%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png)





